---
layout: single
title:  "Python Basics"
categories: coding
tags: [DSA in Python]
toc : true
---

Python Basics

### How to input multiple values from users in one line


```python
x,y = input(), input()

## or

a,b = input().split()
print(a)
print(b)
```

    10 20
    30 40
    a b
    a
    b


### How to typecast built-in function input( )

input( ) function returns a string, so users can typecase to an int or a float.

### What is list comprehension

List comprehension is another way to define and create a list in python.
List comprehension consists of: 
1. Output Expression
2. Input Sequence
3. A variable representing a member of the input sequence
4. optional predicate part
              


```python
## list of odd squares from 1 to 10 using list comprehension

odd_square = [x ** 2 for x in range(1,11) if x % 2 == 1]
print(odd_square)
```

    [1, 9, 25, 49, 81]



```python
## same as the code above
odd2 = []
for x in range(1,11):
    if x % 2 == 1:
        odd2.append(x**2)
print(odd2)
```

    [1, 9, 25, 49, 81]


### Python Operators

* Arithmetic Operators 
    * Arithmetic Operators differ from those of Java in that divison "/" divides into a float and "//" divides with respect to floor rule (similar to that of division in Java.)
    
* Comparison Operators
    * ">=, <=" : the order matters for these greater than or less than signs
    
* Logical Operators
    * Compared to Java operators, Python uses the words "and", "or", and "not" for denoting logical operators
    
* Identity Operator
    * "is" and "is not" are the identity operators both used to check if tow values are located on the same part of the memory
    
* Membership Operators
    * "in" and "not in" are the membership operators both used to test whether a value or variable is in a sequence
    * Sequence in Python are list, tuple, and range

### Writing ternary in Python


```python
## Java
## int a = 20 > 10? 1 : 0;

## Python
a = 1 if 20 > 10 else 0
```

* How is "==" and "is" operator different in Python

"==" is a comparison operator that compares values, whereas the "is" operator is the identity operator that checks whehter the operands refer to the same object or not (same memory location.)

### Data Types in Python

* Strings
    * immutable
    * String.endswith() --> returns true if a string ends with the given suffix otherwise, returns False
    * String.startswith()
    * str.format()
    * str.count
    * str.strip()
        
* Lists
    * uses "[ ]"
    * mutable --> dynamically sized arrays (similar to ArrayList)
    * does not need to be homogeneous
    * may contain duplicate values with their distinct positions
    * used for implementing stacks and queues
    * append() --> adds one element to the list
    * insert('position', 'value') --> adds element at specified index
    * extend() --> adds multiple elements at the end of the list
    * reverse()
    * remove() --> removes a specific element in the list
    * pop() --> removes and returns the last element of the list
    * len() --> returns the size of the list
    * map('function', 'iter') --> returns a list of the results after applying the given function to each item of a given iterable
    * lambda() --> this function can have any number of arguments but only one expression, which is evaluated and returned
        
* Tuples
    * uses "( )"
    * sequenece of immutable Python objects
    * a little bit faster than lists
    * similar to Lists, does not need to be homogeneous
    * complexities for creating tuples: O(1)
    * complexities for accessing tuples: O(1)
    * concatenation of tuples is done by '+' operator, but it can be only done with homogenous tuples
    * sorted('iterable', 'key' for comparison) --> input elements in the tuple and return a new sorted list
    * we generally use 'tuples' for heterogeneous data types and 'lists' for homogenous data types
        
* Sets
    * unordered collection of data types that is iterable, mutable, and has no duplicate elements
    * uses "{ }"
    * set cannot have mutable elements like a list or dictionary, as it is mutable
    * add() --> adds an element to a set
    * remove(), discard() --> removes an element from a set
    * pop() --> removes and returns an arbitrary set element
    * union(), difference(), intersection(), isdisjoint(), issubset() --> set operators
        
* Dictionary
    * unordered collection of data values, used to store data values like map, which holds key:value pair
    * uses "{Key : value}"
    * values in a dictionary can be of any data type and can be duplicated, whereas keys can't be repeated and must be immutable
    * complexities for creating a dictionary: O(len(dict))
    * complexities for adding elements in a dictionary: O(1)/O(n)
    * complexities for accessing elements in a dictionary: O(1)
    * get() --> returns the value of specified key
    * items() --> returns a list containing a tuple for each key value pair
    * keys() --> returns a list containing dictionary's keys
    * pop() --> removes the element with specified key
    * popitem() --> removes the last inserted key-value pair
    * update() --> updates dictionary with specified key-value pairs
    * values() --> returns a list of all the values of dictionary

* Arrays
    * collection of items of the same type stored at contiguous memeory locations
    * array can be created by importing array module --> import array
    * array('data type', 'value_list')
    * compelxities for creationg of arrays: O(1)
    * complexities for adding elements to arrays: O(1)/O(n) for inserting at the end, O(n) for inserting at the beginning
    * complexities for searching elements in arrays: O(n)
    * pop() or remove() used to remove elements
    * insert() or append() used to add elements

### How to use comparison operator Chaining

">" | "<" | "==" | ">=" | "<=" | "!=" | "is" ["not"] | ["not"] "in" all have same interpretation that is conventional in mathematics.

### How to use while loop with list


```python
# checks if list still contains any element
a = [1, 2, 3, 4]

while a:
    print(a.pop())
```

    4
    3
    2
    1


### How to use while loop in a single line

can seperate lines with a semicolon


```python
count = 0
while(count < 5): count += 1; print("Count!")
```

    Count!
    Count!
    Count!
    Count!
    Count!


### Different looping techniques using Python data structures


```python
## using enumerate() to loop through the interable
## in order to print index number along with the value

for key, value in enumerate(['The', 'Big', 'Bang', 'Theory']):
	print(key, value)
```

    0 The
    1 Big
    2 Bang
    3 Theory



```python
## using items() to loop through dictionary printing
## key-value pair sequentially

king = {'Akbar': 'The Great', 'Chandragupta': 'The Maurya',
		'Modi': 'The Changer'}

for key, value in king.items():
	print(key, value)
```

    Akbar The Great
    Chandragupta The Maurya
    Modi The Changer



```python
## using sorted() to print ordered list
## can be combined with set() to remove duplicates

lis = [1, 3, 5, 6, 2, 1, 3]

print("The list in sorted order is : ")
for i in sorted(lis):
	print(i, end=" ")

print("\r")

print("The list in sorted order (without duplicates) is : ")
for i in sorted(set(lis)):
	print(i, end=" ")
```

    The list in sorted order is : 
    1 1 2 3 3 5 6 
    The list in sorted order (without duplicates) is : 
    1 2 3 5 6 

### Syntax of Python Functions

def function_name(parameters):

    """docstring"""
    # body of the function
    return expression

Or

def function_name(parameter: data_type) -> return_type:
    
    """Doctring"""
    # body of the function
    return expression


```python
## example specifying the data and return type

def add(num1: int, num2: int) -> int:
	"""Add two numbers"""
	num3 = num1 + num2

	return num3

num1, num2 = 5, 15
ans = add(num1, num2)
print(f"The addition of {num1} and {num2} results {ans}.")
```

    The addition of 5 and 15 results 20.


### Types of Arguments

* Default Arguments : a parameter that assumes a default value if a value is not provided in the function call for that argument
    * once there is a default argument, all the arguments to its right must also have default values
    
* Keyword Arguments: Python allows functions to be called using keyword arguments. When we call functions in this way, the order (position) of the arguments can be changed.
    * keyword arguments should follow positional arguments

* Docstring: first string after the function which describes the functionality of the function
    * implemented with """ right after the function
    * print('function_name'.__doc__)

### Difference between *args and **kwargs

The special syntax *args in function definitions in Python is used to pass a non-key worded, variable-length argument list. *args allows to take in any number of arguments compared to the number of formal arguments that users previously defined (including zero extra arguments).

The special syntax **kwargs in function definitions in Python allows users to pass through any number of keyword arguments. One can think of kwargs as being a dictionary that maps each keyword to the value that we pass alongside it.


```python
## using *args
def myFun(arg1, *argv):
	print ("First argument :", arg1)
	for arg in argv:
		print("Next argument through *argv :", arg)

myFun('Hello', 'Welcome', 'to', 'GeeksforGeeks')
```

    First argument : Hello
    Next argument through *argv : Welcome
    Next argument through *argv : to
    Next argument through *argv : GeeksforGeeks



```python
def myFun1(*args,**kwargs):
	print("args: ", args)
	print("kwargs: ", kwargs)

myFun1('geeks','for','geeks',first="Geeks",mid="for",last="Geeks")
```

    args:  ('geeks', 'for', 'geeks')
    kwargs:  {'first': 'Geeks', 'mid': 'for', 'last': 'Geeks'}


### What is Generator Expression in Python?

Generator expressions are comparable to list comprehensions, both being another way to generate sequence types such as arrays, tuples, and collections within Python.

Generator expressions are memory-efficient in comparison to list comprehensions, with the use of 'yield' rather than returning the items within the iterator.

Generator expressions are also more time-efficient compared to list comprehensions.

### What is Lambda keyword in Python?

Syntax:
    
    lambda arguments: expression

Lambda keywords are used to create anonymous functions. These functions can have any number of arguments but only one expression, which is evaluate and returned.

We can replace list comprehension with lambda by using map() or filter() methods.


```python
a = [100, 2, 8, 60, 5, 4, 3, 31, 10, 11]

# in filter either we use assignment or conditional operator,
# the pass actual parameter will get return
filtered = filter (lambda x: x % 2 == 0, a)
print(list(filtered))

# in map either we use assignment or conditional operator,
# the result of the value will get returned
mapped = map (lambda x: x % 2 == 0, a)
print(list(mapped))
```

    [100, 2, 8, 60, 4, 10]
    [True, True, True, True, False, True, False, False, True, False]


### How to use global keyword

We only need to use the global keyword in a function if we want to do assignments or change the global variable


```python
a = 1

# Uses global because there is no local 'a'
def f():
	print('Inside f() : ', a)

# Variable 'a' is redefined as a local
def g():
	a = 2
	print('Inside g() : ', a)

# Uses global keyword to modify global 'a'
def h():
	global a
	a = 3
	print('Inside h() : ', a)

# Global scope
print('global : ', a)
f()
print('global : ', a)
g()
print('global : ', a)
h()
print('global : ', a)

```

    global :  1
    Inside f() :  1
    global :  1
    Inside g() :  2
    global :  1
    Inside h() :  3
    global :  3


### First class functions in Python

A programming lnaguange is said to support first-class functions if it treats functions as first-class objects. Python supports the concept of First Class functions.

1. Functions are objects, meaning users can assign function to a variable and that will take the function object referenced by the original function create a second name pointing to it.

2. Functions can be passed as arguments to other functions

3. Functions can return another function

### Nested Functions and Closures in Python

Nested function is a function that are able to access variables of enclosing scope.

Closure is a function object that remembers the values in enclosing scope even if they are not present in memory, a record that stores a function together with an envorinment. Unlike a plain function, closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope.

As closures are used as callback functions, they provide some sort of data hiding, which allows to reduce the use of global variable.

When we have few functions in our code, closures prove to be an efficient way, but with many functions, then go for class (OOP).


```python
# nested functions
def outerFunction(text):
	text = text

	def innerFunction():
		print(text)

	innerFunction()

if __name__ == '__main__':
	outerFunction('Hey!')
```

    Hey!



```python
# closures
def outerFunction(text):
	text = text

	def innerFunction():
		print(text)

	# Note: returning function WITHOUT parenthesis
	return innerFunction

if __name__ == '__main__':
	myFunction = outerFunction('Hey!')
	myFunction()
```

    Hey!


### Decorators in Python

Decorators allow us to wrap another function in order to extend the behavior of the wrapped function, without permanently modifying it.


```python
# defining a decorator
def hello_decorator(func):
    
    # inner1 is a decorator in which the argument is called
    # inner function can access the outer local functions like "func"
    def inner1():
        print("BEFORE function execution")
        
        # calling the actual function inside the decorator function
        func()
        
        print("AFTER the execution")
        
    return inner1


# defining a function to be called inside wrapper
def function_to_be_used():
    print("INSIDE the function!")

    
# passing 'function_to_be_used' inside the decorator to control its behaviour
function_to_be_used = hello_decorator(function_to_be_used)

# calling the function
function_to_be_used()
```

    BEFORE function execution
    INSIDE the function!
    AFTER the execution


### Memoization using decorators in Python

Memoization is the top-down approach to solving a problem with dynamic program. Memoization is a technique of recording the intermediate results so that it can be used to avoid repeated calculations and speed up the programs.


```python
# Simple recursive program to find factorial
def facto(num):
	if num == 1:
		return 1
	else:
		return num * facto(num-1)
		

print(facto(5))
print(facto(5)) # again performing same calculation
```

    120
    120



```python
# Factorial program with memoization using decorators.

# A decorator function for function 'f' passed as parameter
memory = {}
def memoize_factorial(f):

	# This inner function has access to memory and 'f'
	def inner(num):
		if num not in memory:
			memory[num] = f(num)
			print('result saved in memory')
		else:
			print('returning result from saved memory')
		return memory[num]

	return inner


@memoize_factorial
def facto(num):
	if num == 1:
		return 1
	else:
		return num * facto(num-1)

print(facto(5))
print(facto(5)) # directly coming from saved memory
```

    result saved in memory
    result saved in memory
    result saved in memory
    result saved in memory
    result saved in memory
    120
    returning result from saved memory
    120


### The self

Class methods must have an extra first parameter in the method definition. We do not give a value for this parameter when we call the method, Python provides it

If we have a method that takes no arguments, then we still have to have one argument

### "__init__method" == Constructors!

__init__method is similar to constructors in Java. It is used to initialize object's state.

Default constructor is a simple constructor which doesn't accept any arguments.

Parameterized constructor is a constructor with parameters and takes its first argumetn as a reference to the instance being constructed known as self and the rest of the arguments are provided by the programmer.


```python
# Class for Dog
class Dog:
    
    # Class variable
    animal = 'dog'
    
    # The init method (Constructor)
    def __init__(self, breed, color):
        # Instance variable
        self.breed = breed
        self.color = color

Rodger = Dog("Pug", "brown")
print('Rodger details:')  
print('Rodger is a', Rodger.animal)
print('Breed: ', Rodger.breed)
print('Color: ', Rodger.color)
```

    Rodger details:
    Rodger is a dog
    Breed:  Pug
    Color:  brown


### Destructors

Destructors are called when an object gets destroyed.

### Inheritance in Python

Inheritance provides reusability of a code. 


```python
# parent class
class Person( object ):
	def __init__(self, name, idnumber):
		self.name = name
		self.idnumber = idnumber
	def display(self):
		print(self.name)
		print(self.idnumber)

# child class
class Employee( Person ):
	def __init__(self, name, idnumber, salary, post):
		self.salary = salary
		self.post = post

		# invoking the __init__ of the parent class
		Person.__init__(self, name, idnumber)


# creation of an object variable or an instance
a = Employee('Rahul', 886012, 200000, "Intern")

# calling a function of the class Person using its instance
a.display()
```

    Rahul
    886012


Unlike Java, Python shows multiple inheritance.


```python
class Base1(object):
    def __init__(self):
        self.str1 = "Geek1"
        print("Base1")
        
class Base2(object):
    def __init__(self):
        self.str2 = "Geek2"
        print("Base2")

class Derived(Base1, Base2):
    def __init__(self):
        
        Base1.__init__(self)
        Base2.__init__(self)
        print("Derived")
        
    def printStrs(self):
        print(self.str1, self.str2)
        
ob = Derived()
ob.printStrs()
```

    Base1
    Base2
    Derived
    Geek1 Geek2


We can have a child and grandchild relationship --> Multilevel inheritance.

When more than one derived classes are created from a single base --> Hierarchical inheritance.

When we do not want the instance variables of the parent class to be inherited by the child class, we can make some of the instance variables private. We can do that by adding double under scores before its name.


```python
class C(object):
    def __init__(self):
        self.c = 21
        
        # d is private instance variable
        self.__d = 42

class D(C):
    def __init__(self):
        self.e = 84
        C.__init__(self)

object1 = D()
print(object1.d) ## will throw an AttributeError
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-38-40374b247fd2> in <module>
         12 
         13 object1 = D()
    ---> 14 print(object1.d)
    

    AttributeError: 'D' object has no attribute 'd'


### Encapsulation in Python

Protected members are those members of the class that cannot be accessed outside the class but can be accessed from within the class and its subclasses. To accomplish this, users can prefix the name of the member by a single underscore "_".

As stated above, private members are instances that cannot be accessed except inside a class. Users accomplish this by prefixing the name of the member by a double underscore "__".

### Polymorphism in Python

Polymorphism means the same function name (but different signatures) being used for different types.

While method overloading is not supported in Python, method overriding is supported.

### Key Difference between Method Overloading and Overriding

| Overloading      | Overriding |
| ---------------- | ---------- |
| compile-time polymorphism | run-time polymorphism |
| helps to increase readability   | used to grant specific implementation of the method which is already provided by its superclass        |
| occurs within class | performed in 2 classes with inheritance relationship |
| same name, different signatures, not necessarily same return type | same name, signature, return type |
| not supported in Python | always used in Python OOP |

### "Static" in Python

While Java requires specification of static and non-static members, Python does not require a static keyword.

### Class method and Static method

@classmethod is a built-in function decorator that is an expression that gets evalutated after users' function is defined.

A class method is a method that is bound to the class and not the object of the class.

A class method has the access to the state of the class as it takes a class parameter that points to the class and not the object instance.

It can modify a class state that would apply across all the instances of the class. For example, it can modify a class variable that will be applicable to all the instances.

A static method does not receive an implicit first argument, but it is bound to the class and not the object of the class. The difference between class method and static method is that static method cannot access or modify the class state.

Users generally use the class method to create factory methods, while static methods to create utility functions.


```python
from datetime import date

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    # class method to create a Person object by birth year
    @classmethod
    def fromBirthYear(cls, name, year):
        return cls(name, date.today().year - year)
        
    # static method to check if a Person is adult
    @staticmethod
    def isAdult(age):
        return age > 18

person1 = Person("Mike", 21)
person2 = Person.fromBirthYear("Jeongrok", 1998)

print(person1.age)
print(person2.age)

print(Person.isAdult(22))
```

    21
    24
    True

