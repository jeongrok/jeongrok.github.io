---
layout: single
title:  "1.ProductExceptSelf  2.MaximumSubarray"
categories: coding
tags: [LeetCode]
toc : false
---

# *ProductExceptSelf*

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

You must write an algorithm that runs in O(n) time and without using the division operation.


#### Example
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

### Approach 1:

Without reading the question carefully enough, I thought I found a clever way with only 1 iteration along the list, which was have a product of all the values and simply divide the ith value on the output list.

However, without the use of division, I was stuck on how to solve this question.

Looking at the solution, I figured out that I should look at the product of array except self as a product of left part and the right part of the element in the array.
That way, I could iterate through the list twice to keep track of all the left-side products and the right-side products, and ultimately multiply them all together while iterating.

1. Iterate from the left to the right to keep track of all the 'left-side' products
2. Iterate from the right to the left to keep track of all the 'right-side'products
3. While iterating from the right, multiply it with the left-side products to ultimately get the answer


### Implementation:

```python
class Solution:
    

    def productExceptSelf(self, nums):
        m = len(nums)
        result = [1]* m
        for i in range(1,m):
            result[i] = nums[i-1] * result[i-1]
        R = 1
        for i in reversed(range(m)):
            result[i] *= r
            r *= nums[i]
        
        return result
```

#### Complexity Analysis:

Time Complexity:O(n) where n is the length of the list

Space Complexity: O(1)

# *MaximumSubarray*

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A subarray is a contiguous part of an array.


#### Example
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.


### Approach 1:

First, I thought this problem would be easy that I would only have to add positive numbers to maximize the sums.
Naively, I thought that I could cut my subarrays as soon as a negative number appears.
Sadly, this was not the case since that a relatively small negative number (for example -1) can follow a big positive number(10).

Therefore, I thought that I could iterate the list inspecting for all the sums that each addition of elements in the nums could give me, accounting for the fact that the addition of the new element would be actually higher than just the new number itself.

### Implementation:

```python
class Solution:
    

    def maxSubArray(self, nums):
        m = len(nums)
        result = [0] * m
        for i in range(m):
            result[i] = result[i-1] + nums[i] if result[i-1] + nums[i] > nums[i] else nums[i]
        
        return max(profit)
        
```

#### Complexity Analysis:

Time Complexity:O(n) where n is the length of the list nums since we are iterating through the list once, and also using a max function which is a O(n) operation.

Space Complexity: O(n)

### Reflection

It was intersting to see how to tackle these array questions. It was intellectually challenging and more importantly, kind of fun.
