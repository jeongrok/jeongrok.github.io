---
layout: single
title:  "Add Two Numbers! / Linked List Data Structure"
categories: coding
tags: [DSA in Python, LeetCode]
toc : false
---

# *Add Two Numbers*


#### Review Questions:
1. What is heap?

2. What are some applications of heap data structure?

3. What are some useful functions in heapq module?

*Heaps*

Heap is a tree-based data structure in which the tree is a complete binary tree.
Generally, heaps are either max-heap (node being the maximum value) or min-heap (1).
Heapifying is a O(logN) operation while finding the max or min in max-heap/min-heap will be O(1).

Heap sort uses binary heap to sort an array in O(N logN) time, priority queues can be efficiently implemented using binary heap since it supports insert(), delete(), extractmax() all in O(logN) time, and these priority queues are used in graph algorithms such as *Dijkstra's Shortest Path* and *Prim's Minimum Spanning Tree (2).*

Useful Functions in 'heapq' module

* heapify(iterable) --> converts 'iterable' into a heap data structure
* heappush(heap, ele) --> inserts the element while keeping the order and heap data structure
* heappop(heap) --> removes and returns the smallest value from the heap while keeping the order and heap data structure
* heappushpop(heap, ele) --> combination of heappush and heappop
* heappreplace(heap,ele) --> similar to heappushpop, but heap pops an element first, meaning that it will return the smallest value in the original heap regardless of pushed element
* nlargest(k, iterable, key=fun) --> returns the k largest elements from the iterable specified and satisfying the key if mentioned


### Approach 1:

Given that we want to maintain 'N' different variables with each of them pointing to an element in their corresponding list, heap data structure seems really useful.

1. We can first initialize a min-heap H. Since we need to find the kth smallest element, we only need to consider min(N,K) rows where N represents the number of rows.

2. We add min(N,K) elements and heapify the list.

3. At each step, we remove the minimum element from the heap, which tells us which row we need to add the next element(r,c+1), and iterate this process k times.

### Implementation:

```python
import heapq

class Solution(object):
def kthSmallest(self, matrix, k):

        N = len(matrix)
        minHeap = []
        for r in range(min(k,N)):
            minHeap.append((matrix[r][0], r, 0))

        heapq.heapify(minHeap)
        while k:
            element, r, c = heapq.heappop(minHeap)
            if c < N - 1:
                heapq.heappush(minHeap, (matrix[r][c+1], r, c+1))
            k -= 1
            
        return element
```

#### Complexity Analysis:

Time Complexity:O(X + K * logX) where X is min(N,k)

Space Complexity: O(X) which is occupied by the heap.

### Reflection
